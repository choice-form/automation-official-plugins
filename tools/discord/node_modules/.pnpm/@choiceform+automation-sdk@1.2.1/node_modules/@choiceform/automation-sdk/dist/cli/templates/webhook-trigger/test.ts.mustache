import { {{classNamePrefix}}Trigger } from '../src/index.js';
import { TriggerConfig } from '{{{sdkPackageName}}}';
import type { WebhookRequestData } from '../src/types/webhook.js';

describe('{{classNamePrefix}}Trigger', () => {
  let trigger: {{classNamePrefix}}Trigger;
  
  beforeEach(() => {
    const config: TriggerConfig = {
      id: 'test-{{projectName}}-webhook',
      settings: {
        httpMethod: 'POST',
        path: '/test-webhook',
        authentication: 'none',
        respond: 'immediately',
        responseCode: 200,
        responseData: '',
        options: {}
      }
    };
    
    trigger = new {{classNamePrefix}}Trigger(config);
  });

  afterEach(async () => {
    await trigger.stop();
  });

  describe('基础功能', () => {
    test('应该正确初始化 webhook 触发器', async () => {
      await trigger.start();
      
      const webhookUrl = trigger.getWebhookUrl();
      expect(webhookUrl).toBeDefined();
      expect(webhookUrl).toContain('/test-webhook');
    });

    test('应该返回正确的 webhook 信息', () => {
      const info = trigger.getWebhookInfo();
      
      expect(info).toHaveProperty('method');
      expect(info).toHaveProperty('path');
      expect(info).toHaveProperty('authentication');
      expect(info).toHaveProperty('respond');
      expect(info).toHaveProperty('responseCode');
    });
  });

  describe('webhook 请求处理', () => {
    test('应该成功处理有效的 webhook 请求', async () => {
      const requestData: WebhookRequestData = {
        body: { 
          test: 'data',
          message: 'Hello from {{projectName}}' 
        },
        headers: { 
          'content-type': 'application/json',
          'user-agent': 'Test Client'
        },
        hostname: 'localhost',
        method: 'POST',
        params: {},
        query: { 
          source: 'test' 
        },
        url: 'http://localhost:3001/test-webhook'
      };

      const result = await trigger.handleWebhookRequest(requestData);
      
      expect(result.success).toBe(true);
      expect(result.statusCode).toBe(200);
      expect(result.data).toBeDefined();
      expect(result.data.body).toEqual(requestData.body);
      expect(result.data.headers).toEqual(requestData.headers);
    });

    test('应该拒绝不匹配的 HTTP 方法', async () => {
      const requestData: WebhookRequestData = {
        body: {},
        headers: {},
        hostname: 'localhost',
        method: 'GET', // 配置中是 POST
        params: {},
        query: {},
        url: 'http://localhost:3001/test-webhook'
      };

      const result = await trigger.handleWebhookRequest(requestData);
      
      expect(result.success).toBe(false);
      expect(result.statusCode).toBe(405);
      expect(result.data.error).toBe('Method not allowed');
    });

    test('应该处理带参数的请求', async () => {
      const requestData: WebhookRequestData = {
        body: { action: 'create' },
        headers: { 'content-type': 'application/json' },
        hostname: 'localhost',
        method: 'POST',
        params: { id: '123' },
        query: { 
          type: 'webhook',
          source: 'external'
        },
        url: 'http://localhost:3001/test-webhook/123?type=webhook&source=external'
      };

      const result = await trigger.handleWebhookRequest(requestData);
      
      expect(result.success).toBe(true);
      expect(result.data.params).toEqual({ id: '123' });
      expect(result.data.query).toEqual({ 
        type: 'webhook',
        source: 'external'
      });
    });
  });

  describe('手动触发', () => {
    test('应该支持手动触发测试', async () => {
      await trigger.start();
      
      // 这个测试主要检查方法不会抛出异常
      await expect(trigger.manualTrigger()).resolves.not.toThrow();
    });
  });

  describe('配置验证', () => {
    test('应该验证有效配置', () => {
      const validConfig: TriggerConfig = {
        id: 'test',
        settings: {
          httpMethod: 'GET',
          responseCode: 200,
          path: '/valid',
          authentication: 'none',
          respond: 'immediately',
          responseData: '',
          options: {}
        }
      };
      
      expect(trigger['validateConfig'](validConfig)).toBe(true);
    });

    test('应该拒绝无效的 HTTP 方法', () => {
      const invalidConfig: TriggerConfig = {
        id: 'test',
        settings: {
          httpMethod: 'INVALID' as any,
          responseCode: 200,
          path: '/test',
          authentication: 'none',
          respond: 'immediately',
          responseData: '',
          options: {}
        }
      };
      
      expect(trigger['validateConfig'](invalidConfig)).toBe(false);
    });

    test('应该拒绝无效的响应状态码', () => {
      const invalidConfig: TriggerConfig = {
        id: 'test',
        settings: {
          httpMethod: 'POST',
          responseCode: 999, // 无效状态码
          path: '/test',
          authentication: 'none',
          respond: 'immediately',
          responseData: '',
          options: {}
        }
      };
      
      expect(trigger['validateConfig'](invalidConfig)).toBe(false);
    });

    test('应该拒绝缺少设置的配置', () => {
      const invalidConfig: TriggerConfig = {
        id: 'test',
        settings: undefined as any
      };
      
      expect(trigger['validateConfig'](invalidConfig)).toBe(false);
    });
  });

  describe('响应模式', () => {
    test('应该支持立即响应模式', async () => {
      const requestData: WebhookRequestData = {
        body: { test: true },
        headers: {},
        hostname: 'localhost',
        method: 'POST',
        params: {},
        query: {},
        url: 'http://localhost:3001/test-webhook'
      };

      const result = await trigger.handleWebhookRequest(requestData);
      
      expect(result.responseBody).toEqual({
        status: 'received',
        message: 'Workflow got started'
      });
    });

    test('应该支持最后节点响应模式', async () => {
      // 更新配置为 lastNode 模式
      const config: TriggerConfig = {
        id: 'test-lastnode',
        settings: {
          httpMethod: 'POST',
          path: '/test-webhook',
          authentication: 'none',
          respond: 'lastNode',
          responseCode: 200,
          responseData: '',
          options: {}
        }
      };
      
      const lastNodeTrigger = new {{classNamePrefix}}Trigger(config);
      
      const requestData: WebhookRequestData = {
        body: { test: true },
        headers: {},
        hostname: 'localhost',
        method: 'POST',
        params: {},
        query: {},
        url: 'http://localhost:3001/test-webhook'
      };

      const result = await lastNodeTrigger.handleWebhookRequest(requestData);
      
      expect(result.responseBody).toEqual({
        status: 'processing',
        message: 'Will respond when workflow finishes'
      });
    });
  });
}); 