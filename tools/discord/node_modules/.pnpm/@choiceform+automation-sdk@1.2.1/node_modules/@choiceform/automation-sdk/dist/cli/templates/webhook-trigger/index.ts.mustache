import { Trigger as TriggerBase, TriggerEvent, TriggerConfig } from '{{{sdkPackageName}}}';
import type { PluginValue } from '{{{sdkPackageName}}}';
import { nanoid } from 'nanoid';

/**
 * Webhook 触发器配置接口
 */
interface WebhookTriggerSettings extends Record<string, PluginValue> {
  authentication: string;
  httpMethod: string;
  options: {
    allowedOrigins?: string;
    binaryPropertyName?: string;
    ignoreBots?: boolean;
    rawBody?: boolean;
  };
  path: string;
  respond: string;
  responseCode: number;
  responseData: string;
}

interface WebhookTriggerConfig extends TriggerConfig {
  settings: WebhookTriggerSettings;
}

/**
 * HTTP 请求数据接口
 */
interface RequestData {
  body: PluginValue;
  headers: Record<string, PluginValue>;
  hostname: string;
  ip?: string;
  method: string;
  params: Record<string, string>;
  query: Record<string, PluginValue>;
  url: string;
}

/**
 * HTTP Webhook 触发器 - 兼容工作流自动化系统
 * 基于工作流引擎的 Webhook trigger 标准
 */
export class WebhookTrigger extends TriggerBase {
  private triggerId: string = nanoid();
  private webhookUrl: string = '';

  protected async onStart(): Promise<void> {
    const config = this.getConfig() as WebhookTriggerConfig;
    const settings = config.settings;
    
    // 生成 webhook URL
    const webhookId = this.triggerId;
    const webhookPath = (settings.path as string) || `/webhook/${webhookId}`;
    this.webhookUrl = `http://localhost:3001${webhookPath}`;
    
    this.log('info', `Starting webhook trigger on: ${settings.httpMethod} ${this.webhookUrl}`);
    
    // 这里实现实际的 HTTP 服务器启动和路由注册
    // TODO: 根据您的具体需求实现 HTTP 服务器逻辑
    await new Promise(resolve => setTimeout(resolve, 100));
    
    this.log('info', `Webhook trigger listening on ${webhookPath}`);
    
    // 触发初始事件，返回 webhook URL 信息
    const initEvent: TriggerEvent = {
      id: nanoid(),
      timestamp: Date.now(),
      type: 'webhook_initialized',
      data: {
        webhookUrl: this.webhookUrl,
        method: settings.httpMethod,
        path: webhookPath,
        status: 'registered',
      }
    };
    
    await this.triggerEvent(initEvent);
  }

  protected async onStop(): Promise<void> {
    this.log('info', `Webhook trigger stopped: ${this.webhookUrl}`);
  }

  protected async onEvent(event: TriggerEvent): Promise<void> {
    this.log('info', `Processing webhook event: ${event.type}`);
    // 在这里可以添加更多的事件处理逻辑
  }

  /**
   * 处理 webhook 请求
   */
  async handleWebhookRequest(requestData: RequestData): Promise<{
    data: Record<string, PluginValue>;
    responseBody?: PluginValue;
    statusCode: number;
    success: boolean;
  }> {
    const config = this.getConfig() as WebhookTriggerConfig;
    const settings = config.settings;

    // 验证 HTTP 方法
    if (requestData.method.toUpperCase() !== (settings.httpMethod as string).toUpperCase()) {
      return {
        success: false,
        statusCode: 405,
        data: { error: 'Method not allowed' }
      };
    }

    // 创建触发事件
    const eventData: Record<string, PluginValue> = {
      request_data: {
        body: requestData.body,
        headers: requestData.headers,
        hostname: requestData.hostname,
        method: requestData.method,
        params: requestData.params,
        query: requestData.query,
        url: requestData.url,
        ip: requestData.ip || undefined
      },
      headers: requestData.headers,
      body: requestData.body,
      query: requestData.query,
      params: requestData.params,
      method: requestData.method,
      url: requestData.url,
    };

    const event: TriggerEvent = {
      id: nanoid(),
      timestamp: Date.now(),
      type: 'webhook_request',
      data: eventData
    };

    await this.triggerEvent(event);

    // 根据配置返回响应
    let responseBody: PluginValue;
    switch (settings.respond as string) {
      case 'immediately':
        responseBody = { status: 'received', message: 'Workflow got started' };
        break;
      case 'lastNode':
        responseBody = { status: 'processing', message: 'Will respond when workflow finishes' };
        break;
      case 'responseNode':
        responseBody = { status: 'delegated', message: 'Response handled by Respond to Webhook node' };
        break;
      default:
        responseBody = { status: 'received' };
    }

    return {
      success: true,
      statusCode: (settings.responseCode as number) || 200,
      data: eventData,
      responseBody
    };
  }

  /**
   * 手动触发测试
   */
  async manualTrigger(): Promise<void> {
    const config = this.getConfig() as WebhookTriggerConfig;
    const settings = config.settings;

    const mockRequestData: RequestData = {
      headers: {
        'content-type': 'application/json',
        'user-agent': 'Manual Trigger Test',
      },
      body: {
        test: true,
        message: 'Manual trigger test from {{projectName}}',
        timestamp: new Date().toISOString(),
      },
      query: {},
      params: {},
      method: settings.httpMethod as string,
      url: this.webhookUrl,
      hostname: 'localhost',
      ip: '127.0.0.1'
    };

    await this.handleWebhookRequest(mockRequestData);
  }

  /**
   * 获取 webhook URL
   */
  getWebhookUrl(): string {
    return this.webhookUrl;
  }

  /**
   * 获取 webhook 配置信息
   */
  getWebhookInfo(): Record<string, PluginValue> {
    const config = this.getConfig();
    const settings = config?.settings as WebhookTriggerSettings;
    
    if (!settings) {
      return {};
    }
    
    return {
      url: this.webhookUrl,
      method: settings.httpMethod,
      path: settings.path,
      authentication: settings.authentication,
      respond: settings.respond,
      responseCode: settings.responseCode,
      options: settings.options
    };
  }

  /**
   * 配置验证
   */
  protected validateConfig(config: TriggerConfig): boolean {
    if (!config.settings) {
      return false;
    }

    const settings = config.settings as WebhookTriggerSettings;

    // 验证 HTTP 方法
    const validMethods = ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'HEAD'];
    if (!settings.httpMethod || !validMethods.includes((settings.httpMethod as string).toUpperCase())) {
      return false;
    }

    // 验证响应状态码
    const responseCode = settings.responseCode as number;
    if (responseCode && (responseCode < 200 || responseCode > 599)) {
      return false;
    }

    return true;
  }
} 