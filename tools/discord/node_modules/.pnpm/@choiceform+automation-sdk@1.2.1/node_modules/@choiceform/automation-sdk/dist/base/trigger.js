/**
 * 触发器状态
 */
export var TriggerStatus;
(function (TriggerStatus) {
    TriggerStatus["ERROR"] = "error";
    TriggerStatus["RUNNING"] = "running";
    TriggerStatus["STARTING"] = "starting";
    TriggerStatus["STOPPED"] = "stopped";
    TriggerStatus["STOPPING"] = "stopping";
})(TriggerStatus || (TriggerStatus = {}));
/**
 * 触发器基础抽象类
 * 所有触发器插件都应该继承此类
 *
 * 重构后的设计：
 * 1. 简化接口，去除复杂的继承层次
 * 2. 确保与 NodeImplementation 完全兼容
 * 3. 提供清晰的生命周期管理
 */
export class Trigger {
    status = TriggerStatus.STOPPED;
    config = { enabled: false, settings: {} };
    context;
    /**
     * 🔧 重构：兼容 NodeImplementation 接口的初始化方法
     * @param context 执行上下文
     */
    async initialize(context) {
        this.context = context;
        this.log('info', 'Trigger initialized');
    }
    /**
     * 🔧 重构：专用的配置初始化方法
     * @param config 触发器配置
     * @param context 执行上下文
     */
    async initializeWithConfig(config, context) {
        this.config = config;
        this.context = context;
        this.log('info', 'Trigger initialized with configuration');
    }
    /**
     * 启动触发器
     */
    async start() {
        if (this.status === TriggerStatus.RUNNING) {
            this.log('warn', 'Trigger is already running');
            return;
        }
        try {
            this.status = TriggerStatus.STARTING;
            this.log('info', 'Starting trigger...');
            await this.onStart();
            this.status = TriggerStatus.RUNNING;
            this.log('info', 'Trigger started successfully');
        }
        catch (error) {
            this.status = TriggerStatus.ERROR;
            this.log('error', `Failed to start trigger: ${error}`);
            throw error;
        }
    }
    /**
     * 停止触发器
     */
    async stop() {
        if (this.status === TriggerStatus.STOPPED) {
            this.log('warn', 'Trigger is already stopped');
            return;
        }
        try {
            this.status = TriggerStatus.STOPPING;
            this.log('info', 'Stopping trigger...');
            await this.onStop();
            this.status = TriggerStatus.STOPPED;
            this.log('info', 'Trigger stopped successfully');
        }
        catch (error) {
            this.status = TriggerStatus.ERROR;
            this.log('error', `Failed to stop trigger: ${error}`);
            throw error;
        }
    }
    /**
     * 更新配置
     * @param config 新配置
     */
    async updateConfig(config) {
        const wasRunning = this.status === TriggerStatus.RUNNING;
        if (wasRunning) {
            await this.stop();
        }
        this.config = config;
        this.log('info', 'Trigger configuration updated');
        if (wasRunning && config.enabled) {
            await this.start();
        }
    }
    /**
     * 获取当前状态
     */
    getStatus() {
        return this.status;
    }
    /**
     * 获取当前配置
     */
    getConfig() {
        return { ...this.config };
    }
    /**
     * 触发事件
     * @param event 触发事件
     */
    async triggerEvent(event) {
        if (this.status !== TriggerStatus.RUNNING) {
            this.log('warn', 'Trigger is not running, ignoring event');
            return;
        }
        try {
            this.log('info', `Triggering event: ${event.type}`);
            await this.onEvent(event);
        }
        catch (error) {
            this.log('error', `Error handling trigger event: ${error}`);
        }
    }
    /**
     * 验证配置
     * @param config 配置对象
     */
    validateConfig(_config) {
        // 子类可以重写此方法进行自定义验证
        return true;
    }
    /**
     * 安全地记录日志
     */
    log(level, message) {
        if (this.context) {
            try {
                this.context.log(level, `[${this.constructor.name}] ${message}`);
            }
            catch (error) {
                console.error('Failed to log message:', error);
            }
        }
        else {
            console.log(`[${level.toUpperCase()}] [${this.constructor.name}] ${message}`);
        }
    }
    /**
     * 安全地获取凭据
     */
    async getCredential(name) {
        if (!this.context) {
            this.log('error', 'No context available for credential access');
            return undefined;
        }
        try {
            return await this.context.getCredential(name);
        }
        catch (error) {
            this.log('error', `Failed to get credential '${name}': ${error}`);
            return undefined;
        }
    }
    /**
     * 安全地存储数据
     */
    async storeData(key, value) {
        if (!this.context) {
            this.log('error', 'No context available for data storage');
            return;
        }
        try {
            await this.context.storeData(key, value);
            this.log('info', `Data stored with key: ${key}`);
        }
        catch (error) {
            this.log('error', `Failed to store data '${key}': ${error}`);
        }
    }
    /**
     * 安全地检索数据
     */
    async retrieveData(key) {
        if (!this.context) {
            this.log('error', 'No context available for data retrieval');
            return null;
        }
        try {
            return await this.context.retrieveData(key);
        }
        catch (error) {
            this.log('error', `Failed to retrieve data '${key}': ${error}`);
            return null;
        }
    }
    /**
     * 🔧 重构：确保 NodeImplementation 接口兼容性
     *
     * 实现 NodeImplementation 接口要求的 execute 方法
     * 对于触发器，这个方法主要用于：
     * 1. 初始化和启动触发器
     * 2. 手动触发测试
     * 3. 配置更新
     */
    async execute(inputs, context) {
        // 设置上下文
        this.context = context;
        try {
            // 处理配置更新
            if (inputs.config && typeof inputs.config === 'object' && inputs.config !== null && !Array.isArray(inputs.config)) {
                const configObj = inputs.config;
                if ('enabled' in configObj && 'settings' in configObj) {
                    const config = {
                        enabled: Boolean(configObj.enabled),
                        settings: configObj.settings || {}
                    };
                    await this.updateConfig(config);
                }
            }
            // 处理手动触发
            if (inputs.action === 'trigger') {
                if (this.status !== TriggerStatus.RUNNING) {
                    await this.start();
                }
                // 检查是否有手动触发方法并调用
                const triggerInstance = this;
                if (triggerInstance.manualTrigger && typeof triggerInstance.manualTrigger === 'function') {
                    await triggerInstance.manualTrigger();
                }
            }
            // 默认行为：确保触发器运行
            if (this.status === TriggerStatus.STOPPED && this.config.enabled) {
                await this.start();
            }
            return {
                success: true,
                data: {
                    status: this.status,
                    configEnabled: this.config.enabled,
                    message: 'Trigger executed successfully'
                }
            };
        }
        catch (error) {
            return {
                success: false,
                error: {
                    message: error instanceof Error ? error.message : 'Trigger execution failed',
                    code: 'TRIGGER_EXECUTION_ERROR'
                }
            };
        }
    }
    /**
     * 🔧 重构：添加默认的手动触发方法
     * 子类可以重写此方法实现特定的手动触发逻辑
     */
    async manualTrigger() {
        this.log('info', 'Manual trigger called - override this method in subclass for custom behavior');
        // 发送一个默认的测试事件
        const testEvent = {
            id: `manual-${Date.now()}`,
            timestamp: Date.now(),
            type: 'manual_trigger',
            data: {
                source: 'manual',
                message: 'Manual trigger test'
            }
        };
        await this.triggerEvent(testEvent);
    }
    /**
     * 🔧 重构：创建成功结果的辅助方法
     */
    createSuccessResult(data, metadata) {
        return {
            success: true,
            data,
            metadata
        };
    }
    /**
     * 🔧 重构：创建错误结果的辅助方法
     */
    createErrorResult(message, code, details) {
        return {
            success: false,
            error: {
                message,
                code,
                details
            }
        };
    }
}
