/**
 * è§¦å‘å™¨çŠ¶æ€
 */
export var TriggerStatus;
(function (TriggerStatus) {
    TriggerStatus["ERROR"] = "error";
    TriggerStatus["RUNNING"] = "running";
    TriggerStatus["STARTING"] = "starting";
    TriggerStatus["STOPPED"] = "stopped";
    TriggerStatus["STOPPING"] = "stopping";
})(TriggerStatus || (TriggerStatus = {}));
/**
 * è§¦å‘å™¨åŸºç¡€æŠ½è±¡ç±»
 * æ‰€æœ‰è§¦å‘å™¨æ’ä»¶éƒ½åº”è¯¥ç»§æ‰¿æ­¤ç±»
 *
 * é‡æ„åçš„è®¾è®¡ï¼š
 * 1. ç®€åŒ–æ¥å£ï¼Œå»é™¤å¤æ‚çš„ç»§æ‰¿å±‚æ¬¡
 * 2. ç¡®ä¿ä¸ NodeImplementation å®Œå…¨å…¼å®¹
 * 3. æä¾›æ¸…æ™°çš„ç”Ÿå‘½å‘¨æœŸç®¡ç†
 */
export class Trigger {
    status = TriggerStatus.STOPPED;
    config = { enabled: false, settings: {} };
    context;
    /**
     * ğŸ”§ é‡æ„ï¼šå…¼å®¹ NodeImplementation æ¥å£çš„åˆå§‹åŒ–æ–¹æ³•
     * @param context æ‰§è¡Œä¸Šä¸‹æ–‡
     */
    async initialize(context) {
        this.context = context;
        this.log('info', 'Trigger initialized');
    }
    /**
     * ğŸ”§ é‡æ„ï¼šä¸“ç”¨çš„é…ç½®åˆå§‹åŒ–æ–¹æ³•
     * @param config è§¦å‘å™¨é…ç½®
     * @param context æ‰§è¡Œä¸Šä¸‹æ–‡
     */
    async initializeWithConfig(config, context) {
        this.config = config;
        this.context = context;
        this.log('info', 'Trigger initialized with configuration');
    }
    /**
     * å¯åŠ¨è§¦å‘å™¨
     */
    async start() {
        if (this.status === TriggerStatus.RUNNING) {
            this.log('warn', 'Trigger is already running');
            return;
        }
        try {
            this.status = TriggerStatus.STARTING;
            this.log('info', 'Starting trigger...');
            await this.onStart();
            this.status = TriggerStatus.RUNNING;
            this.log('info', 'Trigger started successfully');
        }
        catch (error) {
            this.status = TriggerStatus.ERROR;
            this.log('error', `Failed to start trigger: ${error}`);
            throw error;
        }
    }
    /**
     * åœæ­¢è§¦å‘å™¨
     */
    async stop() {
        if (this.status === TriggerStatus.STOPPED) {
            this.log('warn', 'Trigger is already stopped');
            return;
        }
        try {
            this.status = TriggerStatus.STOPPING;
            this.log('info', 'Stopping trigger...');
            await this.onStop();
            this.status = TriggerStatus.STOPPED;
            this.log('info', 'Trigger stopped successfully');
        }
        catch (error) {
            this.status = TriggerStatus.ERROR;
            this.log('error', `Failed to stop trigger: ${error}`);
            throw error;
        }
    }
    /**
     * æ›´æ–°é…ç½®
     * @param config æ–°é…ç½®
     */
    async updateConfig(config) {
        const wasRunning = this.status === TriggerStatus.RUNNING;
        if (wasRunning) {
            await this.stop();
        }
        this.config = config;
        this.log('info', 'Trigger configuration updated');
        if (wasRunning && config.enabled) {
            await this.start();
        }
    }
    /**
     * è·å–å½“å‰çŠ¶æ€
     */
    getStatus() {
        return this.status;
    }
    /**
     * è·å–å½“å‰é…ç½®
     */
    getConfig() {
        return { ...this.config };
    }
    /**
     * è§¦å‘äº‹ä»¶
     * @param event è§¦å‘äº‹ä»¶
     */
    async triggerEvent(event) {
        if (this.status !== TriggerStatus.RUNNING) {
            this.log('warn', 'Trigger is not running, ignoring event');
            return;
        }
        try {
            this.log('info', `Triggering event: ${event.type}`);
            await this.onEvent(event);
        }
        catch (error) {
            this.log('error', `Error handling trigger event: ${error}`);
        }
    }
    /**
     * éªŒè¯é…ç½®
     * @param config é…ç½®å¯¹è±¡
     */
    validateConfig(_config) {
        // å­ç±»å¯ä»¥é‡å†™æ­¤æ–¹æ³•è¿›è¡Œè‡ªå®šä¹‰éªŒè¯
        return true;
    }
    /**
     * å®‰å…¨åœ°è®°å½•æ—¥å¿—
     */
    log(level, message) {
        if (this.context) {
            try {
                this.context.log(level, `[${this.constructor.name}] ${message}`);
            }
            catch (error) {
                console.error('Failed to log message:', error);
            }
        }
        else {
            console.log(`[${level.toUpperCase()}] [${this.constructor.name}] ${message}`);
        }
    }
    /**
     * å®‰å…¨åœ°è·å–å‡­æ®
     */
    async getCredential(name) {
        if (!this.context) {
            this.log('error', 'No context available for credential access');
            return undefined;
        }
        try {
            return await this.context.getCredential(name);
        }
        catch (error) {
            this.log('error', `Failed to get credential '${name}': ${error}`);
            return undefined;
        }
    }
    /**
     * å®‰å…¨åœ°å­˜å‚¨æ•°æ®
     */
    async storeData(key, value) {
        if (!this.context) {
            this.log('error', 'No context available for data storage');
            return;
        }
        try {
            await this.context.storeData(key, value);
            this.log('info', `Data stored with key: ${key}`);
        }
        catch (error) {
            this.log('error', `Failed to store data '${key}': ${error}`);
        }
    }
    /**
     * å®‰å…¨åœ°æ£€ç´¢æ•°æ®
     */
    async retrieveData(key) {
        if (!this.context) {
            this.log('error', 'No context available for data retrieval');
            return null;
        }
        try {
            return await this.context.retrieveData(key);
        }
        catch (error) {
            this.log('error', `Failed to retrieve data '${key}': ${error}`);
            return null;
        }
    }
    /**
     * ğŸ”§ é‡æ„ï¼šç¡®ä¿ NodeImplementation æ¥å£å…¼å®¹æ€§
     *
     * å®ç° NodeImplementation æ¥å£è¦æ±‚çš„ execute æ–¹æ³•
     * å¯¹äºè§¦å‘å™¨ï¼Œè¿™ä¸ªæ–¹æ³•ä¸»è¦ç”¨äºï¼š
     * 1. åˆå§‹åŒ–å’Œå¯åŠ¨è§¦å‘å™¨
     * 2. æ‰‹åŠ¨è§¦å‘æµ‹è¯•
     * 3. é…ç½®æ›´æ–°
     */
    async execute(inputs, context) {
        // è®¾ç½®ä¸Šä¸‹æ–‡
        this.context = context;
        try {
            // å¤„ç†é…ç½®æ›´æ–°
            if (inputs.config && typeof inputs.config === 'object' && inputs.config !== null && !Array.isArray(inputs.config)) {
                const configObj = inputs.config;
                if ('enabled' in configObj && 'settings' in configObj) {
                    const config = {
                        enabled: Boolean(configObj.enabled),
                        settings: configObj.settings || {}
                    };
                    await this.updateConfig(config);
                }
            }
            // å¤„ç†æ‰‹åŠ¨è§¦å‘
            if (inputs.action === 'trigger') {
                if (this.status !== TriggerStatus.RUNNING) {
                    await this.start();
                }
                // æ£€æŸ¥æ˜¯å¦æœ‰æ‰‹åŠ¨è§¦å‘æ–¹æ³•å¹¶è°ƒç”¨
                const triggerInstance = this;
                if (triggerInstance.manualTrigger && typeof triggerInstance.manualTrigger === 'function') {
                    await triggerInstance.manualTrigger();
                }
            }
            // é»˜è®¤è¡Œä¸ºï¼šç¡®ä¿è§¦å‘å™¨è¿è¡Œ
            if (this.status === TriggerStatus.STOPPED && this.config.enabled) {
                await this.start();
            }
            return {
                success: true,
                data: {
                    status: this.status,
                    configEnabled: this.config.enabled,
                    message: 'Trigger executed successfully'
                }
            };
        }
        catch (error) {
            return {
                success: false,
                error: {
                    message: error instanceof Error ? error.message : 'Trigger execution failed',
                    code: 'TRIGGER_EXECUTION_ERROR'
                }
            };
        }
    }
    /**
     * ğŸ”§ é‡æ„ï¼šæ·»åŠ é»˜è®¤çš„æ‰‹åŠ¨è§¦å‘æ–¹æ³•
     * å­ç±»å¯ä»¥é‡å†™æ­¤æ–¹æ³•å®ç°ç‰¹å®šçš„æ‰‹åŠ¨è§¦å‘é€»è¾‘
     */
    async manualTrigger() {
        this.log('info', 'Manual trigger called - override this method in subclass for custom behavior');
        // å‘é€ä¸€ä¸ªé»˜è®¤çš„æµ‹è¯•äº‹ä»¶
        const testEvent = {
            id: `manual-${Date.now()}`,
            timestamp: Date.now(),
            type: 'manual_trigger',
            data: {
                source: 'manual',
                message: 'Manual trigger test'
            }
        };
        await this.triggerEvent(testEvent);
    }
    /**
     * ğŸ”§ é‡æ„ï¼šåˆ›å»ºæˆåŠŸç»“æœçš„è¾…åŠ©æ–¹æ³•
     */
    createSuccessResult(data, metadata) {
        return {
            success: true,
            data,
            metadata
        };
    }
    /**
     * ğŸ”§ é‡æ„ï¼šåˆ›å»ºé”™è¯¯ç»“æœçš„è¾…åŠ©æ–¹æ³•
     */
    createErrorResult(message, code, details) {
        return {
            success: false,
            error: {
                message,
                code,
                details
            }
        };
    }
}
