import fs from 'fs-extra';
import path from 'path';
import mustache from 'mustache';
import { getSdkVersionWithPrefix, getSdkPackageName } from './version.js';
import { fileURLToPath } from 'url';
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
export async function renderTemplate(templateName, outputPath, data) {
    // 动态获取 SDK 版本
    const sdkVersion = await getSdkVersionWithPrefix();
    const sdkPackageName = getSdkPackageName();
    console.log('🔧 [DEBUG] Template name:', templateName);
    console.log('🔧 [DEBUG] Plugin type:', data.pluginType);
    // 🔧 完全重构：直接在这里处理所有变量名生成
    const safeProjectName = makeSafeIdentifier(data.projectName);
    // 🔧 对所有 trigger 类型统一使用 WebhookTrigger
    let className = 'WebhookTrigger';
    let registrationName = 'webhookTriggerRegistration';
    let configInterfaceName = 'WebhookTriggerConfig';
    let settingsInterfaceName = 'WebhookTriggerSettings';
    // 如果不是 trigger 类型，使用项目名生成
    if (data.pluginType !== 'trigger') {
        const projectPrefix = capitalizeFirst(safeProjectName);
        className = `${projectPrefix}${capitalizeFirst(data.pluginType)}`;
        registrationName = `${safeProjectName}${capitalizeFirst(data.pluginType)}Registration`;
        configInterfaceName = `${projectPrefix}${capitalizeFirst(data.pluginType)}Config`;
        settingsInterfaceName = `${projectPrefix}${capitalizeFirst(data.pluginType)}Settings`;
    }
    // 扩展模板上下文
    const context = {
        ...data,
        sdkVersion,
        sdkPackageName,
        classNamePrefix: className, // 保持兼容性
        // 🔧 使用统一的命名
        className: className,
        registrationName: registrationName,
        configInterfaceName: configInterfaceName,
        settingsInterfaceName: settingsInterfaceName,
        safeProjectName: safeProjectName,
        hasHttpIntegration: data.features.includes('http'),
        hasCredentials: data.features.includes('credentials'),
        hasPersistence: data.features.includes('persistence'),
        hasEvents: data.features.includes('events'),
        hasDebug: data.features.includes('debug'),
        hasHealth: data.features.includes('health')
    };
    console.log('🔧 [FINAL DEBUG] Template context:');
    console.log('  - className:', context.className);
    console.log('  - registrationName:', context.registrationName);
    console.log('  - safeProjectName:', context.safeProjectName);
    // 根据插件类型和功能选择合适的模板
    const templateKey = getTemplateKey(data.pluginType, data.features);
    // 渲染模板
    await renderTemplateFromDirectory(templateKey, outputPath, context);
}
function getTemplateKey(pluginType, features) {
    // 根据插件类型和功能特性决定使用哪个模板
    // 所有 trigger 类型默认使用 webhook-trigger 模板（最常用）
    if (pluginType === 'trigger') {
        return 'webhook-trigger';
    }
    if (pluginType === 'action' && features.includes('http')) {
        return 'http-action';
    }
    if (pluginType === 'transform') {
        return 'data-transform';
    }
    // 默认通用模板
    return 'generic';
}
async function renderTemplateFromDirectory(templateKey, outputPath, context) {
    const templatesDir = path.join(__dirname, '..', 'templates');
    const templateDir = path.join(templatesDir, templateKey);
    console.log('🔧 [DEBUG] Template directory:', templateDir);
    // 检查模板目录是否存在
    if (!(await fs.pathExists(templateDir))) {
        throw new Error(`模板 "${templateKey}" 不存在`);
    }
    // 读取模板配置
    const configPath = path.join(templateDir, 'template.config.js');
    let templateConfig;
    let finalContext = context;
    console.log('🔧 [DEBUG] Config path:', configPath);
    console.log('🔧 [DEBUG] Config exists:', await fs.pathExists(configPath));
    if (await fs.pathExists(configPath)) {
        try {
            // 动态导入配置
            console.log('🔧 [DEBUG] Importing config...');
            const configModule = await import(configPath);
            templateConfig = configModule.default || configModule;
            console.log('🔧 [DEBUG] Template config loaded:', templateConfig.name);
            console.log('🔧 [DEBUG] Has generateTemplateData:', typeof templateConfig.generateTemplateData);
            // 🔧 重构：正确应用 generateTemplateData
            if (typeof templateConfig.generateTemplateData === 'function') {
                console.log('🔧 [DEBUG] Calling generateTemplateData...');
                const customData = templateConfig.generateTemplateData(context.projectName, context);
                console.log('🔧 [DEBUG] Custom data:', customData);
                // 🔧 关键修复：正确合并自定义数据，确保覆盖原有变量
                finalContext = { ...context, ...customData };
                console.log('🔧 [DEBUG] Final context className:', finalContext.className);
                console.log('🔧 [DEBUG] Final context registrationName:', finalContext.registrationName);
            }
        }
        catch (error) {
            console.error('🔧 [ERROR] Failed to load template config:', error);
            throw error;
        }
    }
    else {
        console.log('🔧 [DEBUG] No config file found, using default config');
        // 默认配置 - 扫描所有 .mustache 文件
        const files = await fs.readdir(templateDir);
        const mustacheFiles = files.filter(file => file.endsWith('.mustache'));
        templateConfig = {
            name: templateKey,
            description: `Template for ${templateKey}`,
            files: mustacheFiles.map(file => ({
                source: file,
                target: file.replace('.mustache', '')
            })),
            features: [],
            complexity: 'intermediate'
        };
    }
    console.log('🔧 [DEBUG] Final template config files:', templateConfig.files?.length || 0);
    // 创建输出目录结构
    await createOutputDirectories(outputPath, templateConfig, finalContext);
    // 渲染模板文件
    for (const file of templateConfig.files || []) {
        console.log('🔧 [DEBUG] Rendering file:', file.source, '->', file.target);
        await renderTemplateFile(templateDir, outputPath, file, finalContext);
    }
    // 生成通用配置文件
    await createCommonFiles(outputPath, finalContext, templateConfig);
}
async function createOutputDirectories(outputPath, config, context) {
    // 创建基础目录
    await fs.ensureDir(outputPath);
    await fs.ensureDir(path.join(outputPath, 'src'));
    await fs.ensureDir(path.join(outputPath, 'src', 'types'));
    await fs.ensureDir(path.join(outputPath, 'tests'));
    // 如果有高级功能，创建额外目录
    if (context.advanced) {
        await fs.ensureDir(path.join(outputPath, 'docs'));
        await fs.ensureDir(path.join(outputPath, 'src', 'utils'));
    }
}
async function renderTemplateFile(templateDir, outputPath, file, context) {
    const sourceFile = path.join(templateDir, file.source);
    if (!(await fs.pathExists(sourceFile))) {
        if (file.required) {
            throw new Error(`必需的模板文件 "${file.source}" 不存在`);
        }
        return;
    }
    // 读取模板内容
    const templateContent = await fs.readFile(sourceFile, 'utf-8');
    // 渲染模板
    const renderedContent = mustache.render(templateContent, context);
    // 确定输出路径
    let targetPath = path.join(outputPath, file.target);
    // 如果目标是源代码文件，放到 src 目录
    if (file.target.endsWith('.ts') && !file.target.startsWith('tests/')) {
        targetPath = path.join(outputPath, 'src', path.basename(file.target));
    }
    // 如果是测试文件，放到 tests 目录
    if (file.target.includes('test') || file.target.includes('spec')) {
        targetPath = path.join(outputPath, 'tests', path.basename(file.target));
    }
    // 创建目标目录（如果不存在）
    await fs.ensureDir(path.dirname(targetPath));
    // 写入文件
    await fs.writeFile(targetPath, renderedContent);
}
async function createCommonFiles(outputPath, context, config) {
    // package.json
    const packageJson = {
        name: context.projectName,
        version: '1.0.0',
        description: context.description,
        main: 'dist/index.js',
        types: 'dist/index.d.ts',
        scripts: {
            build: 'tsc',
            dev: 'automation-plugin dev',
            validate: 'automation-plugin validate',
            test: 'vitest',
            lint: 'eslint src --ext .ts',
            'type-check': 'tsc --noEmit'
        },
        dependencies: {
            [context.sdkPackageName]: context.sdkVersion,
            ...(config.dependencies ? Object.fromEntries(config.dependencies.map(dep => [dep, 'latest'])) : {}),
            ...(context.hasHttpIntegration ? { 'nanoid': '^5.0.0' } : {})
        },
        devDependencies: {
            'typescript': '^5.3.0',
            'vitest': '^1.0.0',
            'eslint': '^8.57.0',
            '@typescript-eslint/parser': '^6.0.0',
            '@typescript-eslint/eslint-plugin': '^6.0.0',
            ...(config.devDependencies ? Object.fromEntries(config.devDependencies.map(dep => [dep, 'latest'])) : {})
        },
        keywords: [
            'automation',
            'workflow',
            'node',
            'flow-engine',
            context.pluginType,
            'typescript',
            ...config.features,
            ...(context.hasHttpIntegration ? ['http', 'webhook'] : [])
        ]
    };
    await fs.writeJson(path.join(outputPath, 'package.json'), packageJson, { spaces: 2 });
    // plugin.manifest.json
    const manifest = {
        name: context.projectName,
        version: '1.0.0',
        description: context.description,
        author: context.author,
        type: context.pluginType,
        features: context.features,
        advanced: context.advanced,
        template: {
            name: config.name,
            complexity: config.complexity
        },
        sdk: {
            version: '^1.0.0',
            compatibility: 'node-based-workflow',
            features: [
                'hot-reload',
                'type-safety',
                'validation',
                'nodes-config-compatible',
                'workflow-integration'
            ]
        },
        permissions: context.hasCredentials ? ['credentials'] : [],
        metadata: {
            createdAt: context.date,
            framework: 'automation-plugin-sdk',
            compatibility: 'workflow-automation-system',
            architecture: 'node-based'
        }
    };
    await fs.writeJson(path.join(outputPath, 'plugin.manifest.json'), manifest, { spaces: 2 });
    // tsconfig.json
    const tsConfig = {
        compilerOptions: {
            target: 'ES2020',
            module: 'ESNext',
            moduleResolution: 'node',
            outDir: 'dist',
            rootDir: 'src',
            strict: true,
            esModuleInterop: true,
            skipLibCheck: true,
            forceConsistentCasingInFileNames: true,
            declaration: true,
            declarationMap: true,
            sourceMap: true
        },
        include: ['src/**/*'],
        exclude: ['node_modules', 'dist', 'tests']
    };
    await fs.writeJson(path.join(outputPath, 'tsconfig.json'), tsConfig, { spaces: 2 });
    // .gitignore
    const gitignore = `node_modules/
dist/
*.log
.env
.env.local
.DS_Store
*.tsbuildinfo`;
    await fs.writeFile(path.join(outputPath, '.gitignore'), gitignore);
}
function capitalizeFirst(str) {
    if (!str)
        return 'Plugin';
    return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
}
// 🔧 重构：创建安全的 JavaScript 标识符
function makeSafeIdentifier(input) {
    return input
        .replace(/[^a-zA-Z0-9]/g, '') // 移除所有非字母数字字符
        .replace(/^[0-9]/, '_$&') // 如果以数字开头，添加下划线
        .toLowerCase();
}
