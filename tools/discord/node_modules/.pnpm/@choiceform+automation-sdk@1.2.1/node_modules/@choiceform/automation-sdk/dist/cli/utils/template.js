import fs from 'fs-extra';
import path from 'path';
import mustache from 'mustache';
import { getSdkVersionWithPrefix, getSdkPackageName } from './version.js';
import { fileURLToPath } from 'url';
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
export async function renderTemplate(templateName, outputPath, data) {
    // åŠ¨æ€è·å– SDK ç‰ˆæœ¬
    const sdkVersion = await getSdkVersionWithPrefix();
    const sdkPackageName = getSdkPackageName();
    console.log('ğŸ”§ [DEBUG] Template name:', templateName);
    console.log('ğŸ”§ [DEBUG] Plugin type:', data.pluginType);
    // ğŸ”§ å®Œå…¨é‡æ„ï¼šç›´æ¥åœ¨è¿™é‡Œå¤„ç†æ‰€æœ‰å˜é‡åç”Ÿæˆ
    const safeProjectName = makeSafeIdentifier(data.projectName);
    // ğŸ”§ å¯¹æ‰€æœ‰ trigger ç±»å‹ç»Ÿä¸€ä½¿ç”¨ WebhookTrigger
    let className = 'WebhookTrigger';
    let registrationName = 'webhookTriggerRegistration';
    let configInterfaceName = 'WebhookTriggerConfig';
    let settingsInterfaceName = 'WebhookTriggerSettings';
    // å¦‚æœä¸æ˜¯ trigger ç±»å‹ï¼Œä½¿ç”¨é¡¹ç›®åç”Ÿæˆ
    if (data.pluginType !== 'trigger') {
        const projectPrefix = capitalizeFirst(safeProjectName);
        className = `${projectPrefix}${capitalizeFirst(data.pluginType)}`;
        registrationName = `${safeProjectName}${capitalizeFirst(data.pluginType)}Registration`;
        configInterfaceName = `${projectPrefix}${capitalizeFirst(data.pluginType)}Config`;
        settingsInterfaceName = `${projectPrefix}${capitalizeFirst(data.pluginType)}Settings`;
    }
    // æ‰©å±•æ¨¡æ¿ä¸Šä¸‹æ–‡
    const context = {
        ...data,
        sdkVersion,
        sdkPackageName,
        classNamePrefix: className, // ä¿æŒå…¼å®¹æ€§
        // ğŸ”§ ä½¿ç”¨ç»Ÿä¸€çš„å‘½å
        className: className,
        registrationName: registrationName,
        configInterfaceName: configInterfaceName,
        settingsInterfaceName: settingsInterfaceName,
        safeProjectName: safeProjectName,
        hasHttpIntegration: data.features.includes('http'),
        hasCredentials: data.features.includes('credentials'),
        hasPersistence: data.features.includes('persistence'),
        hasEvents: data.features.includes('events'),
        hasDebug: data.features.includes('debug'),
        hasHealth: data.features.includes('health')
    };
    console.log('ğŸ”§ [FINAL DEBUG] Template context:');
    console.log('  - className:', context.className);
    console.log('  - registrationName:', context.registrationName);
    console.log('  - safeProjectName:', context.safeProjectName);
    // æ ¹æ®æ’ä»¶ç±»å‹å’ŒåŠŸèƒ½é€‰æ‹©åˆé€‚çš„æ¨¡æ¿
    const templateKey = getTemplateKey(data.pluginType, data.features);
    // æ¸²æŸ“æ¨¡æ¿
    await renderTemplateFromDirectory(templateKey, outputPath, context);
}
function getTemplateKey(pluginType, features) {
    // æ ¹æ®æ’ä»¶ç±»å‹å’ŒåŠŸèƒ½ç‰¹æ€§å†³å®šä½¿ç”¨å“ªä¸ªæ¨¡æ¿
    // æ‰€æœ‰ trigger ç±»å‹é»˜è®¤ä½¿ç”¨ webhook-trigger æ¨¡æ¿ï¼ˆæœ€å¸¸ç”¨ï¼‰
    if (pluginType === 'trigger') {
        return 'webhook-trigger';
    }
    if (pluginType === 'action' && features.includes('http')) {
        return 'http-action';
    }
    if (pluginType === 'transform') {
        return 'data-transform';
    }
    // é»˜è®¤é€šç”¨æ¨¡æ¿
    return 'generic';
}
async function renderTemplateFromDirectory(templateKey, outputPath, context) {
    const templatesDir = path.join(__dirname, '..', 'templates');
    const templateDir = path.join(templatesDir, templateKey);
    console.log('ğŸ”§ [DEBUG] Template directory:', templateDir);
    // æ£€æŸ¥æ¨¡æ¿ç›®å½•æ˜¯å¦å­˜åœ¨
    if (!(await fs.pathExists(templateDir))) {
        throw new Error(`æ¨¡æ¿ "${templateKey}" ä¸å­˜åœ¨`);
    }
    // è¯»å–æ¨¡æ¿é…ç½®
    const configPath = path.join(templateDir, 'template.config.js');
    let templateConfig;
    let finalContext = context;
    console.log('ğŸ”§ [DEBUG] Config path:', configPath);
    console.log('ğŸ”§ [DEBUG] Config exists:', await fs.pathExists(configPath));
    if (await fs.pathExists(configPath)) {
        try {
            // åŠ¨æ€å¯¼å…¥é…ç½®
            console.log('ğŸ”§ [DEBUG] Importing config...');
            const configModule = await import(configPath);
            templateConfig = configModule.default || configModule;
            console.log('ğŸ”§ [DEBUG] Template config loaded:', templateConfig.name);
            console.log('ğŸ”§ [DEBUG] Has generateTemplateData:', typeof templateConfig.generateTemplateData);
            // ğŸ”§ é‡æ„ï¼šæ­£ç¡®åº”ç”¨ generateTemplateData
            if (typeof templateConfig.generateTemplateData === 'function') {
                console.log('ğŸ”§ [DEBUG] Calling generateTemplateData...');
                const customData = templateConfig.generateTemplateData(context.projectName, context);
                console.log('ğŸ”§ [DEBUG] Custom data:', customData);
                // ğŸ”§ å…³é”®ä¿®å¤ï¼šæ­£ç¡®åˆå¹¶è‡ªå®šä¹‰æ•°æ®ï¼Œç¡®ä¿è¦†ç›–åŸæœ‰å˜é‡
                finalContext = { ...context, ...customData };
                console.log('ğŸ”§ [DEBUG] Final context className:', finalContext.className);
                console.log('ğŸ”§ [DEBUG] Final context registrationName:', finalContext.registrationName);
            }
        }
        catch (error) {
            console.error('ğŸ”§ [ERROR] Failed to load template config:', error);
            throw error;
        }
    }
    else {
        console.log('ğŸ”§ [DEBUG] No config file found, using default config');
        // é»˜è®¤é…ç½® - æ‰«ææ‰€æœ‰ .mustache æ–‡ä»¶
        const files = await fs.readdir(templateDir);
        const mustacheFiles = files.filter(file => file.endsWith('.mustache'));
        templateConfig = {
            name: templateKey,
            description: `Template for ${templateKey}`,
            files: mustacheFiles.map(file => ({
                source: file,
                target: file.replace('.mustache', '')
            })),
            features: [],
            complexity: 'intermediate'
        };
    }
    console.log('ğŸ”§ [DEBUG] Final template config files:', templateConfig.files?.length || 0);
    // åˆ›å»ºè¾“å‡ºç›®å½•ç»“æ„
    await createOutputDirectories(outputPath, templateConfig, finalContext);
    // æ¸²æŸ“æ¨¡æ¿æ–‡ä»¶
    for (const file of templateConfig.files || []) {
        console.log('ğŸ”§ [DEBUG] Rendering file:', file.source, '->', file.target);
        await renderTemplateFile(templateDir, outputPath, file, finalContext);
    }
    // ç”Ÿæˆé€šç”¨é…ç½®æ–‡ä»¶
    await createCommonFiles(outputPath, finalContext, templateConfig);
}
async function createOutputDirectories(outputPath, config, context) {
    // åˆ›å»ºåŸºç¡€ç›®å½•
    await fs.ensureDir(outputPath);
    await fs.ensureDir(path.join(outputPath, 'src'));
    await fs.ensureDir(path.join(outputPath, 'src', 'types'));
    await fs.ensureDir(path.join(outputPath, 'tests'));
    // å¦‚æœæœ‰é«˜çº§åŠŸèƒ½ï¼Œåˆ›å»ºé¢å¤–ç›®å½•
    if (context.advanced) {
        await fs.ensureDir(path.join(outputPath, 'docs'));
        await fs.ensureDir(path.join(outputPath, 'src', 'utils'));
    }
}
async function renderTemplateFile(templateDir, outputPath, file, context) {
    const sourceFile = path.join(templateDir, file.source);
    if (!(await fs.pathExists(sourceFile))) {
        if (file.required) {
            throw new Error(`å¿…éœ€çš„æ¨¡æ¿æ–‡ä»¶ "${file.source}" ä¸å­˜åœ¨`);
        }
        return;
    }
    // è¯»å–æ¨¡æ¿å†…å®¹
    const templateContent = await fs.readFile(sourceFile, 'utf-8');
    // æ¸²æŸ“æ¨¡æ¿
    const renderedContent = mustache.render(templateContent, context);
    // ç¡®å®šè¾“å‡ºè·¯å¾„
    let targetPath = path.join(outputPath, file.target);
    // å¦‚æœç›®æ ‡æ˜¯æºä»£ç æ–‡ä»¶ï¼Œæ”¾åˆ° src ç›®å½•
    if (file.target.endsWith('.ts') && !file.target.startsWith('tests/')) {
        targetPath = path.join(outputPath, 'src', path.basename(file.target));
    }
    // å¦‚æœæ˜¯æµ‹è¯•æ–‡ä»¶ï¼Œæ”¾åˆ° tests ç›®å½•
    if (file.target.includes('test') || file.target.includes('spec')) {
        targetPath = path.join(outputPath, 'tests', path.basename(file.target));
    }
    // åˆ›å»ºç›®æ ‡ç›®å½•ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
    await fs.ensureDir(path.dirname(targetPath));
    // å†™å…¥æ–‡ä»¶
    await fs.writeFile(targetPath, renderedContent);
}
async function createCommonFiles(outputPath, context, config) {
    // package.json
    const packageJson = {
        name: context.projectName,
        version: '1.0.0',
        description: context.description,
        main: 'dist/index.js',
        types: 'dist/index.d.ts',
        scripts: {
            build: 'tsc',
            dev: 'automation-plugin dev',
            validate: 'automation-plugin validate',
            test: 'vitest',
            lint: 'eslint src --ext .ts',
            'type-check': 'tsc --noEmit'
        },
        dependencies: {
            [context.sdkPackageName]: context.sdkVersion,
            ...(config.dependencies ? Object.fromEntries(config.dependencies.map(dep => [dep, 'latest'])) : {}),
            ...(context.hasHttpIntegration ? { 'nanoid': '^5.0.0' } : {})
        },
        devDependencies: {
            'typescript': '^5.3.0',
            'vitest': '^1.0.0',
            'eslint': '^8.57.0',
            '@typescript-eslint/parser': '^6.0.0',
            '@typescript-eslint/eslint-plugin': '^6.0.0',
            ...(config.devDependencies ? Object.fromEntries(config.devDependencies.map(dep => [dep, 'latest'])) : {})
        },
        keywords: [
            'automation',
            'workflow',
            'node',
            'flow-engine',
            context.pluginType,
            'typescript',
            ...config.features,
            ...(context.hasHttpIntegration ? ['http', 'webhook'] : [])
        ]
    };
    await fs.writeJson(path.join(outputPath, 'package.json'), packageJson, { spaces: 2 });
    // plugin.manifest.json
    const manifest = {
        name: context.projectName,
        version: '1.0.0',
        description: context.description,
        author: context.author,
        type: context.pluginType,
        features: context.features,
        advanced: context.advanced,
        template: {
            name: config.name,
            complexity: config.complexity
        },
        sdk: {
            version: '^1.0.0',
            compatibility: 'node-based-workflow',
            features: [
                'hot-reload',
                'type-safety',
                'validation',
                'nodes-config-compatible',
                'workflow-integration'
            ]
        },
        permissions: context.hasCredentials ? ['credentials'] : [],
        metadata: {
            createdAt: context.date,
            framework: 'automation-plugin-sdk',
            compatibility: 'workflow-automation-system',
            architecture: 'node-based'
        }
    };
    await fs.writeJson(path.join(outputPath, 'plugin.manifest.json'), manifest, { spaces: 2 });
    // tsconfig.json
    const tsConfig = {
        compilerOptions: {
            target: 'ES2020',
            module: 'ESNext',
            moduleResolution: 'node',
            outDir: 'dist',
            rootDir: 'src',
            strict: true,
            esModuleInterop: true,
            skipLibCheck: true,
            forceConsistentCasingInFileNames: true,
            declaration: true,
            declarationMap: true,
            sourceMap: true
        },
        include: ['src/**/*'],
        exclude: ['node_modules', 'dist', 'tests']
    };
    await fs.writeJson(path.join(outputPath, 'tsconfig.json'), tsConfig, { spaces: 2 });
    // .gitignore
    const gitignore = `node_modules/
dist/
*.log
.env
.env.local
.DS_Store
*.tsbuildinfo`;
    await fs.writeFile(path.join(outputPath, '.gitignore'), gitignore);
}
function capitalizeFirst(str) {
    if (!str)
        return 'Plugin';
    return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
}
// ğŸ”§ é‡æ„ï¼šåˆ›å»ºå®‰å…¨çš„ JavaScript æ ‡è¯†ç¬¦
function makeSafeIdentifier(input) {
    return input
        .replace(/[^a-zA-Z0-9]/g, '') // ç§»é™¤æ‰€æœ‰éå­—æ¯æ•°å­—å­—ç¬¦
        .replace(/^[0-9]/, '_$&') // å¦‚æœä»¥æ•°å­—å¼€å¤´ï¼Œæ·»åŠ ä¸‹åˆ’çº¿
        .toLowerCase();
}
